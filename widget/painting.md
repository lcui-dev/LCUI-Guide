# 绘制流程

LCUI 的绘制流程是由脏矩形驱动的，窗口尺寸变化和组件的样式变化都会产生脏矩形，这些脏矩形主要集中在样式计算阶段和布局阶段产生，当脏矩形记录不为空时就会进入绘制流程，绘制流程由以下步骤组成：

* **开始绘制：**根据当前所在窗口和脏矩形，创建一个绘制上下文，包含绘制区域和充当画布的图形对象，其中图形对象引用自帧缓冲，而帧缓冲与应用程序窗口绑定，对该图形对象写入像素数据会同步到窗口中。
* **绘制组件树：**以根组件为起点，递归向下遍历整个组件树中的组件，将所有出现在脏矩形内的组件都绘制到画布中。
* **结束绘制：**销毁绘制上下文，释放相关资源。

所有脏矩形都重绘完后，LCUI 会调用系统提供的窗口 API 将帧缓冲的内容写入到窗口内以让窗口呈现最新内容。接下来我们将深入了解与绘制流程相关的功能和工作原理。

### 脏矩形

相较于画面更新频繁且内容很多的图形游戏，普通应用的界面更新频率要低得很多，而更新的内容通常也不是很多，甚至只是一个小区域（例如：按钮），如果像游戏一样强制重绘的话会造成资源浪费，对用户而言最明显的感受就是风扇转速和电量消耗速度都很快。脏矩形技术正是利用只更新变化区域来达到提高绘制效率的目的。在脏矩形系统中，屏幕上更新的区域被称为“脏矩形”，绘制引擎仅对脏矩形部分重绘，而其他部分保持原样。

出于性能和内存开销上的考虑，LCUI 中的脏矩形系统采用如下设计：

* 每个组件中都有一个脏矩形类型标识和记录，其中类型标识有五个值：`none`、`custom`、`padding-box`、`border-box`、`canvas-box`，当值为 `custom` 时使用脏矩形记录中的准确数据。
* 在样式计算阶段和布局阶段，组件自身的位置、尺寸、透明度、边框、背景等视觉样式发生变化时会更新脏矩形类型标识。如果组件有自己的绘制逻辑，则会通过调用相关函数来更新脏矩形记录。
* 在脏矩形收集阶段，整个过程是从根组件开始向下遍历整个组件树，组件的脏矩形仅在不被父组件脏矩形包含且在可视区域内时才被收集；收集脏矩形时如果与已有的脏矩形相重叠，则会将它们合并成一个；收集完后重置组件的脏矩形记录。

这种设计的好处是在判断脏矩形是否存在和是否重叠时，只需要简单的比较标识值的大小即可，也就是将矩形间的 `x`、`y`、`width`、`height` 的复杂比较简化成单个值的比较，极大的提升了脏矩形收集、去重和合并性能。

### 并行绘制

绘制本质上是将计算结果写入内存中，这些任务相互独立，可以分配给多个 CPU 核心同时执行以提升绘制效率。

LCUI 采用的策略如下：

* 根据屏幕尺寸和预设的并行渲染线程数量，将屏幕区域从上到下划分成多个小区域。
* 分别为这些小区域收集脏矩形，当已收集的脏矩形总面积超过区域面积的 80% 时，将整个区域作为脏矩形，不再逐个重绘脏矩形。
* 当脏矩形总面积超过两个区域面积时，开启并行绘制。这样做是因为并行特性本身也有性能开销，如果计算量过少的话，很容易会导致性能降低。

（示例图）

### 绘制组件



### 图层

图层是一个用于存放临时绘制内容的图形对象，LCUI 在绘制组件时会用到三个图层：

* 组件自身图层：当组件透明度不为 `1.0` 时会使用该图层。
* 组件内容图层：当组件透明度不为 `1.0` 或有圆角边框时会使用该图层。
* 合成图层：当组件透明度不为 `1.0` 时会使用该图层。

### 绘制上下文



### 实例演示

（示例图）



